using System.Diagnostics.CodeAnalysis;
using Tuxedo.SourceGenerator.Extensions;

namespace Tuxedo.SourceGenerator;

public sealed partial class RefinementSourceGenerator
{
    private sealed class MultiRefinedTypeModel : SingleRefinedTypeModel
    {
        public string? AlternativeType { get; set; }
    }

    [SuppressMessage(
        "Design",
        "MA0051:Method is too long",
        Justification = "template needs to be in one method"
    )]
    private static string RenderMultiRefinedType(MultiRefinedTypeModel model)
    {
        var rawImplicitConversion = $$"""
            /// <summary>
            /// Implicit conversion from the refined to the raw value
            /// </summary>
            /// <param name="this">refined value</param>
            /// <returns>underlying raw value</returns>
            public static implicit operator {{model.RawType}}({{model.RefinedType}}{{model.Generics}} @this)
            {
                return @this.RawValue;
            }
            """;

        return $$"""
            // <auto-generated/>
            #nullable enable

            using System.Diagnostics.CodeAnalysis;

            namespace {{model.Namespace}};

            /// <summary>
            /// A refined {{model.RawType.EscapeXml()}} based on the {{model.Predicate.EscapeXml()}} refinement predicate which produces an alternative type {{model.AlternativeType.EscapeXml()}}
            /// </summary>
            {{model.AccessModifier}} readonly partial struct {{model.RefinedType}}{{model.Generics}}
            {{model.GenericConstraints}}
            {
                private readonly {{model.RawType}}? _rawValue;
                private readonly {{model.AlternativeType}}? _alternativeValue;

                /// <summary>
                /// The underlying refined value
                /// </summary>
                public {{model.RawType}} RawValue => _rawValue ?? throw new InvalidOperationException("Do not use the default value, please use the Parse and TryParse methods to construct a {{model.RefinedType}}");
                
                /// <summary>
                /// The alternative value produced by refining the raw value
                /// </summary>
                public {{model.AlternativeType}} RefinedValue => _alternativeValue ?? throw new InvalidOperationException("Do not use the default value, please use the Parse and TryParse methods to construct a {{model.RefinedType}}");
                
                private {{model.RefinedType}}({{model.RawType}} rawValue, {{model.AlternativeType}} refinedValue)
                {
                    _rawValue = rawValue;
                    _alternativeValue = refinedValue;
                }

                {{(
                !string.Equals(model.RawType, model.AlternativeType, StringComparison.Ordinal)
                    ? rawImplicitConversion
                    : string.Empty
            )}}

                /// <summary>
                /// Implicit conversion from the refined to the refined value
                /// </summary>
                /// <param name="this">refined value</param>
                /// <returns>underlying refined value</returns>
                public static implicit operator {{model.AlternativeType}}({{model.RefinedType}}{{model.Generics}} @this)
                {
                    return @this.RefinedValue;
                }

                /// <summary>
                /// Explicit conversion from the raw to the refined value
                /// </summary>
                /// <param name="value">raw value</param>
                /// <returns>refined value</returns>
                /// <exception cref="InvalidOperationException">if the refinement fails</exception>
                public static explicit operator {{model.RefinedType}}{{model.Generics}}({{model.RawType}} value)
                {
                    return Parse(value);
                }

                /// <summary>
                /// Try and refine the raw value
                /// </summary>
                /// <param name="value">raw value</param>
                /// <param name="refined">refined value</param>
                /// <param name="failureMessage">error message</param>
                /// <returns>true if refined, false otherwise</returns>
                public static bool TryParse(
                    {{model.RawType}} value,
                    out {{model.RefinedType}}{{model.Generics}} refined,
                    [NotNullWhen(false)] out string? failureMessage
                )
                {
                    if ({{model.Predicate}}{{model.Generics}}(value, out var alternative))
                    {
                        refined = new {{model.RefinedType}}{{model.Generics}}(value, alternative);
                        failureMessage = null;
                        return true;
                    }
                    
                    refined = default!;
                    failureMessage = ${{model.FailureMessage}};
                    return false;
                }

                /// <summary>
                /// Refines the value or throws
                /// </summary>
                /// <param name="value">raw value</param>
                /// <returns>refined value</returns>
                /// <exception cref="InvalidOperationException">if the refinement fails</exception>
                public static {{model.RefinedType}}{{model.Generics}} Parse({{model.RawType}} value)
                {
                    return TryParse(value, out var result, out var failureMessage) ? result : throw new InvalidOperationException(failureMessage);
                }
                
                /// <summary>
                /// Standard deconstruction to the underlying values
                /// </summary>
                /// <param name="rawValue">raw value</param>
                /// <param name="refined">refined value</param>
                public void Deconstruct(out {{model.RawType}} rawValue, out {{model.AlternativeType}} refined)
                {
                     rawValue = RawValue;
                     refined = RefinedValue;
                }
            }
            """;
    }
}
