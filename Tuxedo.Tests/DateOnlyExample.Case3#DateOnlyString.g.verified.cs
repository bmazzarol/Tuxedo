//HintName: DateOnlyString.g.cs
// <auto-generated/>
#nullable enable

using System.Diagnostics.CodeAnalysis;

namespace <global namespace>;

/// <summary>
/// A refined string based on the Test.DateOnly refinement predicate which produces an alternative value DateOnly
/// </summary>
public readonly partial struct DateOnlyString
   
{
    private readonly string? _rawValue;
    private readonly DateOnly? _alternativeValue;

    /// <summary>
    /// The underlying refined value
    /// </summary>
    public string RawValue => _rawValue ?? throw new InvalidOperationException("Do not use the default value, please use the Parse and TryParse methods to construct a DateOnlyString");
    
    /// <summary>
    /// The alternative value produced by refining the raw value
    /// </summary>
    public DateOnly RefinedValue => _alternativeValue ?? throw new InvalidOperationException("Do not use the default value, please use the Parse and TryParse methods to construct a DateOnlyString");
    
    private DateOnlyString(string rawValue, DateOnly refinedValue)
    {
        _rawValue = rawValue;
        _alternativeValue = refinedValue;
    }

    /// <summary>
/// Implicit conversion from the refined to the raw value
/// </summary>
/// <param name="this">refined value</param>
/// <returns>underlying raw value</returns>
public static implicit operator string(DateOnlyString @this)
{
    return @this.RawValue;
}

    /// <summary>
    /// Implicit conversion from the refined to the refined value
    /// </summary>
    /// <param name="this">refined value</param>
    /// <returns>underlying refined value</returns>
    public static implicit operator DateOnly(DateOnlyString @this)
    {
        return @this.RefinedValue;
    }

    /// <summary>
    /// Explicit conversion from the raw to the refined value
    /// </summary>
    /// <param name="value">raw value</param>
    /// <returns>refined value</returns>
    /// <exception cref="InvalidOperationException">if the refinement fails</exception>
    public static explicit operator DateOnlyString(string value)
    {
        return Parse(value);
    }

    /// <summary>
    /// Try and refine the raw value
    /// </summary>
    /// <param name="value">raw value</param>
    /// <param name="refined">refined value</param>
    /// <param name="failureMessage">error message</param>
    /// <returns>true if refined, false otherwise</returns>
    public static bool TryParse(
        string value,
        out DateOnlyString refined,
        [NotNullWhen(false)] out string? failureMessage
    )
    {
        if (Test.DateOnly(value, out var alternative))
        {
            refined = new DateOnlyString(value, alternative);
            failureMessage = null;
            return true;
        }
        
        refined = default!;
        failureMessage = $"The value must be a valid date, but was '{value}'";
        return false;
    }

    /// <summary>
    /// Refines the value or throws
    /// </summary>
    /// <param name="value">raw value</param>
    /// <returns>refined value</returns>
    /// <exception cref="InvalidOperationException">if the refinement fails</exception>
    public static DateOnlyString Parse(string value)
    {
        return TryParse(value, out var result, out var failureMessage) ? result : throw new InvalidOperationException(failureMessage);
    }
    
    /// <summary>
    /// Standard deconstruction to the underlying values
    /// </summary>
    /// <param name="rawValue">raw value</param>
    /// <param name="refined">refined value</param>
    public void Deconstruct(out string rawValue, out DateOnly refined)
    {
         rawValue = RawValue;
         refined = RefinedValue;
    }
}